Here is the detailed breakdown for the second milestone: **Basic Environment**.

This milestone shifts from simple initialization to actually putting pixels on the headset screens. This requires establishing a "handshake" between your OpenGL rendering engine and the OpenXR runtime.

Here is the updated breakdown for the second milestone, incorporating your request for a **Desktop Mirror/Debug Window** to view the headset's perspective.

### **Phase 1: Graphics Binding & Context Strategy**

OpenXR "takes over" the rendering flow, but it needs an existing OpenGL context to work with. Since RuneLite has its own render loop (often running at ~50fps), and VR requires a steady 90Hz+, you must decouple them.

1.  **Thread Creation:** Spawn a new, dedicated thread (e.g., `VRRenderThread`). This thread will handle the high-frequency VR tracking and rendering loop, independent of the RuneLite client logic speed.
2.  **Shared Context & Mirror Window:**
    * On this new thread, create a **secondary GLFW window**.
    * **Change:** Instead of making this window "invisible," make it **visible**. This will act as your "Spectator View" for recording or debugging. Set its title to "RuneLite XR Debug View".
    * **Crucial Step:** Configure this window to **share resources (Context Sharing)** with the main RuneLite window. This allows your VR thread to eventually "read" the textures (like the inventory or chat box) generated by the main game thread.
    * Make this new context "Current" on the VR thread.
3.  **Graphics Binding Struct:** Populate the `XrGraphicsBindingOpenGLWin32KHR` (or Linux equivalent) structure using the handles from this new visible GLFW window.

### **Phase 2: Session & Reference Spaces**

Once the graphics binding is ready, you can fully start the VR session.

1.  **Create Session:** Call `xrCreateSession` passing in your Graphics Binding. This tells SteamVR: "I am ready to render frames using this specific OpenGL context."
2.  **Create Reference Space:** You need to define the coordinate system.
    * **Action:** Create a `LOCAL` reference space (`XR_REFERENCE_SPACE_TYPE_LOCAL`).
    * **Why:** `LOCAL` places (0,0,0) at the user's initial head position (or calibrated center). This is ideal for a "seated/tabletop" experience like RuneLite XR.
3.  **Create Swapchains:** These are the "framebuffers" for the headset.
    * **Enumerate Views:** Ask OpenXR for the configuration (usually 2 views: Left Eye, Right Eye) and their recommended resolution.
    * **Create Swapchain:** For each view, create a Swapchain. This gives you a list of OpenGL Texture Handles (`GL_TEXTURE_2D`) that OpenXR owns but you can write to.

### **Phase 3: The VR Render Loop (With Mirroring)**

This is the standard game loop, but we will add a step to copy the VR view to the desktop window.

1.  **Poll Events:** Check `xrPollEvent` every frame to handle state changes.
2.  **Wait Frame:** Call `xrWaitFrame`. This pauses your thread until the headset is ready for the next image.
3.  **Begin Frame:** Call `xrBeginFrame`.
4.  **Render Pass (The "Draw" Step):**
    * **Acquire Image:** Ask the Swapchain for the next available texture index.
    * **Wait Image:** Wait until the runtime releases ownership of that texture.
    * **Draw:** (See Phase 4).
    * **Release Image:** Give the texture back to OpenXR.
5.  **Desktop Mirroring (New Step):**
    * After drawing both eyes (Phase 4), take the texture handle from the **Left Eye Swapchain** (which usually represents what is seen on the 2D screen).
    * Bind default framebuffer `glBindFramebuffer(GL_FRAMEBUFFER, 0)` (which targets your new GLFW window).
    * **Blit:** Use `glBlitFramebuffer` to copy the pixels from the Left Eye FBO to the Desktop Window's back buffer.
    * **Swap Buffers:** Call `glfwSwapBuffers` on your secondary window to display the image on your monitor.
6.  **End Frame:** Call `xrEndFrame`. You pass the rendered layers to this function to be displayed on the device.

### **Phase 4: Rendering the Skybox**

Now you have a texture to draw on.

1.  **Resource Loading:** Load a Cubemap texture (or 6 individual images) and compile a simple Shader Program (Vertex + Fragment) capable of sampling a cubemap.
2.  **Targeting the Swapchain:**
    * Instead of `glBindFramebuffer(0)`, you must create a custom **Frame Buffer Object (FBO)**.
    * Attach the specific **Swapchain Texture** (from Phase 3) to this FBO as the `GL_COLOR_ATTACHMENT0`.
3.  **The Draw Call:**
    * Clear the screen (optional if drawing a full skybox).
    * Disable Depth Testing (`glDisable(GL_DEPTH_TEST)`).
    * Bind your Skybox Shader and Cubemap.
    * **View Matrix:** Use the `Pose` returned by `xrWaitFrame` (inverted) to calculate the camera rotation.
    * **Projection Matrix:** Use the `Fov` returned by `xrWaitFrame` to calculate the projection.
    * Draw a Cube.
4.  **Repeat:** Do this twice per frameâ€”once for the Left Eye swapchain, once for the Right Eye swapchain.

### **Phase 5: Validation**
How to verify this milestone is complete:

1.  **Launch:** Start RuneLite and initiate the VR session.
2.  **Headset Check:** Put on the VR headset. You should see the skybox in 3D.
3.  **Desktop Mirror Check:** Look at your monitor.
    * **Success:** You should see a new window (separate from the RuneLite client) displaying the **Left Eye** view of the skybox.
    * **Movement:** When you move your head, this window should update in real-time, mirroring exactly what you see in your left eye.
    * **Recording:** You can now capture this window with OBS for footage.